import pandas as pd
import subprocess
import os
import sys
import re

# IMPLEMENTED BY SILVIA

def get_checker_result(checker_exe, txt_file, debug):
    
    DFG_ERROR_PATTERN = r"total # of errors = (\d+)"

    if os.path.exists(txt_file):
        try:
            # Run checker executable


            if debug:
                debug_raw = "1"
                print(f"Executing: {checker_exe} {txt_file} {debug_raw}")
            else:
                debug_raw = "0"

            # Commands to pass to subprocess
            cmd_args = [checker_exe, txt_file, debug_raw]

            result = subprocess.run(cmd_args, capture_output=True, text=True, timeout=20)
            
            if debug:
                print(f"Checker stdout: {result.stdout}")
                print(f"Checker stderr: {result.stderr}")

            output = result.stdout.lower() + result.stderr.lower()
            
            match = re.search(DFG_ERROR_PATTERN, output.lower())
        
            if match:
                # Capture the number of errors
                total_errors = int(match.group(1))
                
                # Check the extracted value
                if total_errors == 0:

                    # Success case
                    return "CHECKER_PASS"
                else:
                    # Failure case
                    return f"CHECKER_FAIL ({total_errors} errors)"
            else:
                # If the specific metric line was not found, something structural is wrong 
                # (e.g., checker crashed before completion, or output format changed)
                return "CHECKER_FAIL (Output metric not found)"

        except subprocess.TimeoutExpired:
            return "TIMEOUT" # If the checker hangs for too long
        except Exception as e:
            return f"ERROR: {str(e)}"


def main():
    
    if len(sys.argv) < 4:
        print("Usage: python3 run_checker.py <csv_file> <checker_exe> <debug>")
        sys.exit(1)

    # Parse command-line arguments
    csv_file_path = sys.argv[1]
    checker_exe = sys.argv[2]
    debug = sys.argv[3] == "1"

    # Extract directory and filename
    csv_dir = os.path.dirname(csv_file_path)
    
    results_dir = csv_dir.replace("CSV", "Results")

    csv_filename = os.path.basename(csv_file_path)

    # Pattern 1: Complete filename with S and P
    pattern_full = r"^Results_(?P<alg_name>.+)_(?:.+?)_S(?P<featS>\d+)_P(?P<featP>\d+).*$"
    
    # Pattern 2: Base filename without S and P 
    pattern_base = r"^Results_(?P<alg_name>.+)_(?:.+?)\.csv$"

    match = re.search(pattern_full, csv_filename)
    
    is_base_mode = False

    if match:
        # Found format with features
        alg_name = match.group('alg_name')
        featS = match.group('featS')
        featP = match.group('featP')
    else:
        # Try base format
        match = re.search(pattern_base, csv_filename)
        if match:
            # Found base format
            alg_name = match.group('alg_name')
            featS = "0" # Default for base
            featP = "0" # Default for base
            is_base_mode = True

        else:
            print(f"Error: Could not parse filename format: {csv_filename}")
            sys.exit(1)
    
    # Load the CSV generated by C++
    df = pd.read_csv(csv_file_path)

    if debug:
        print(f"Algorithm: {alg_name} | BaseMode: {is_base_mode}")
        print(f"Reading CSV from: {csv_dir}")
        print(f"Looking for TXT results in: {results_dir}\n")
    
    # List to store checker results
    checker_results = []

    for index, row in df.iterrows():

        dfg_name = str(row['DFG_Name'])

        prefix = "Results_"

        if is_base_mode:
            txt_filename = f"{prefix}{alg_name}_{dfg_name}.txt"
        else:
            
            txt_filename = f"{prefix}{alg_name}_{dfg_name}_S{featS}_P{featP}.txt"

        
        if debug:
            print(f"Checking DFG: {dfg_name}")
            print(f"Target File: {txt_filename}")

        full_txt_path = os.path.join(results_dir, txt_filename)

        res = get_checker_result(checker_exe, full_txt_path, debug)
        checker_results.append(res)
        
        if debug:   
            print(f"Checking {dfg_name}: {res}\n")

    # Add the checker status column to DataFrame
    df['Checker_Status'] = checker_results

    # Save the final report to a new CSV file
    df.to_csv(csv_file_path, index=False)

    if debug:
        print(f"\nFinal Report generated: {csv_file_path}")

if __name__ == "__main__":
    main()