import pandas as pd
import subprocess
import os
import sys
import re

# IMPLEMENTED BY SILVIA

def get_checker_result(checker_exe, txt_file, debug):
    
    DFG_ERROR_PATTERN = r"total # of errors = (\d+)"

    if os.path.exists(txt_file):
        try:
            # Run checker executable

            if debug:
                print(f"Executing: {checker_exe} {txt_file}")

            result = subprocess.run([checker_exe, txt_file], capture_output=True, text=True, timeout=20)
            
            if debug:
                print(f"Checker stdout: {result.stdout}")
                print(f"Checker stderr: {result.stderr}")
            output = result.stdout.lower() + result.stderr.lower()
            
            
            match = re.search(DFG_ERROR_PATTERN, output.lower())
        
            if match:
                # Capture the number of errors
                total_errors = int(match.group(1))
                
                # Check the extracted value
                if total_errors == 0:

                    # Success case
                    return "CHECKER_PASS"
                else:
                    # Failure case
                    return f"CHECKER_FAIL ({total_errors} errors)"
            else:
                # If the specific metric line was not found, something structural is wrong 
                # (e.g., checker crashed before completion, or output format changed)
                return "CHECKER_FAIL (Output metric not found)"

        except subprocess.TimeoutExpired:
            return "TIMEOUT" # If the checker hangs for too long
        except Exception as e:
            return f"ERROR: {str(e)}"


def main():
    
    if len(sys.argv) < 4:
        print("Usage: python3 run_checker.py <csv_file> <checker_exe> <debug>")
        sys.exit(1)

    # Parse command-line arguments
    csv_file = sys.argv[1]
    checker_exe = sys.argv[2]
    debug = sys.argv[3] == "1"

    # Extract additional parameters form csv file name
    pattern = r"^\.\/Results_(?P<alg_name>.+)_(?:.+?)_S(?P<featS>\d+)_P(?P<featP>\d+).*$"

    match = re.search(pattern, csv_file)
    alg_name = match.group('alg_name')
    featS = match.group('featS')
    featP = match.group('featP')

    if debug:
        print(f"Algorithm Name: {alg_name}")
        print(f"Feature S: {featS}")
        print(f"Feature P: {featP}\n")

    if not os.path.exists(csv_file):
        print(f"Error: CSV file {csv_file} not found.")
        sys.exit(1)
    
    # Load the CSV generated by C++
    df = pd.read_csv(csv_file)

    if debug:
        print(f"Loaded CSV file: {csv_file}\n")
    
    # List to store checker results
    checker_results = []

    for index, row in df.iterrows():

        dfg_name = row['DFG_Name']

        # Construct the text file path
        output_txt_file = f"Results/{alg_name}_{dfg_name}_S{featS}_P{featP}.txt"
        
        if debug:
            print(f"Running checker on: {output_txt_file}")

        res = get_checker_result(checker_exe, output_txt_file, debug)
        checker_results.append(res)
        
        if debug:   
            print(f"Checking {dfg_name}: {res}\n")

    # Add the checker status column to DataFrame
    df['Checker_Status'] = checker_results

    # Save the final report to a new CSV file
    final_csv_file = csv_file.replace(".csv", "_checker_report.csv")
    df.to_csv(final_csv_file, index=False)

    if debug:
        print(f"\nFinal Report generated: {final_csv_file}")


if __name__ == "__main__":
    main()